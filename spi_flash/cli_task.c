#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "driverlib/sysctl.h"
#include "driverlib/gpio.h"
#include "driverlib/rom.h"
#include "utils/uartstdio.h"
#include "cli_task.h"
#include "priorities.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include "FreeRTOS_CLI.h"
#include <string.h>

#define CLITASKSTACKSIZE	512 // Stack size in words
#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100
static const char* pcWelcomeMessage = "FreeRTOS command server.\r\nType \'help\' to view a list of registered commands.\r\n";
static const char* pcPrompt = ">";

static void CLITask(void *pvParameters)
{
	unsigned char cRxedChar;
	unsigned char cInputIndex = 0;
	portBASE_TYPE xMoreDataToFollow;
	/* The input and output buffers are declared static to keep them off the stack. */
	static int8_t pcOutputString[MAX_OUTPUT_LENGTH];
	static int8_t pcInputString[MAX_INPUT_LENGTH];

	/* Send a welcome message to the user knows they are connected. */
    UARTprintf(pcWelcomeMessage);
    UARTprintf(pcPrompt);

	while(1)
	{
		/* This implementation reads a single character at a time.  Wait in the
		Blocked state until a character is received. */
		cRxedChar = UARTgetc();

		if(cRxedChar == '\r')
		{
			/* A newline character was received, so the input command string is
			complete and can be processed.  Transmit a line separator, just to
			make the output easier to read. */
			UARTprintf("\r\n");

			/* The command interpreter is called repeatedly until it returns
			pdFALSE.  See the "Implementing a command" documentation for an
			explanation of why this is. */
			do
			{
				/* Send the command string to the command interpreter.  Any
				output generated by the command interpreter will be placed in the pcOutputString buffer. */
				xMoreDataToFollow = FreeRTOS_CLIProcessCommand(pcInputString, pcOutputString, MAX_OUTPUT_LENGTH);

				/* Write the output generated by the command interpreter to the	console. */
				UARTprintf((const char*)pcOutputString);

			} while(xMoreDataToFollow != pdFALSE);

			/* All the strings generated by the input command have been sent.
			Processing of the command is complete.  Clear the input string ready
			to receive the next command. */
			cInputIndex = 0;
			memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
			UARTprintf(pcPrompt);
		}
		else
		{
			/* The if() clause performs the processing after a newline character
			is received.  This else clause performs the processing if any other
			character is received. */

			/* Echo back typed character */
			UARTprintf("%c", cRxedChar);

			if(cRxedChar == '\b')
			{
				/* Backspace was pressed.  Erase the last character in the input
				buffer - if there are any. */
				if(cInputIndex > 0)
				{
					cInputIndex--;
					pcInputString[cInputIndex] = '\0';
				}
			}
			else
			{
				/* A character was entered.  It was not a new line, backspace
				or carriage return, so it is accepted as part of the input and
				placed into the input buffer.  When a \n is entered the complete
				string will be passed to the command interpreter. */
				if( cInputIndex < MAX_INPUT_LENGTH )
				{
					pcInputString[cInputIndex] = cRxedChar;
					cInputIndex++;
				}
			}
		}
	}
}

unsigned long CLITaskInit(void)
{
    if(xTaskCreate(CLITask, (signed portCHAR *)"CLI", CLITASKSTACKSIZE, NULL, tskIDLE_PRIORITY + PRIORITY_CLI_TASK, NULL) != pdTRUE)
        return(1);
    return(0);
}
